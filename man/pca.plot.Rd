% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pca.plot.R
\name{pca.plot}
\alias{pca.plot}
\title{Plot ordination of Principal Components with convex hulls}
\usage{
pca.plot(PCA.out = NULL, PCs = c(1, 2), groups = NULL,
  col.gp = grDevices::rainbow(length(levels(groups))),
  conv.hulls = NULL,
  col.conv = grDevices::rainbow(length(levels(conv.hulls))),
  leg = FALSE, leg.labels = groups, leg.pos = "topright",
  main = "Ordination of PCA coordinates", sp.as = "points",
  sp.text = NULL)
}
\arguments{
\item{PCA.out}{the output of a Principal Components Analysis performed by \code{\link{prcomp}} function (\code{\link{stats}} package). By default: \code{PCA.out = NULL} (i.e. output must be specified before ploting)}

\item{PCs}{a vector of length two with the Principal Components intended for the plot. By default: \code{PCs = c(1, 2)}}

\item{groups}{groups to use as colors and/or convex hulls. Must be a \code{factor} object with the same length as the number of rows in the coordinates of \code{PCA.out} (i.e. \code{length(groups) == nrow(PCA.out$x)}). By default: \code{groups = NULL} (i.e. \code{factor} must be specified before ploting)}

\item{col.gp}{a \code{factor} object with the colours intended for \code{groups}. Must be the same length as the number of levels from \code{groups} (i.e. \code{length(col.gp) == length(levels(groups))}). By default: \code{col.gp = grDevices::rainbow(length(levels(groups)))} (i.e. colors defined automatically)}

\item{conv.hulls}{groups to use for convex hulls. Must be a \code{factor} object with the same length as the number of rows in the coordinates of \code{PCA.out} (i.e. \code{length(conv.hulls) == nrow(PCA.out$x)}). By default: \code{conv.hulls = NULL} (i.e. plot without convex hulls)}

\item{col.conv}{a \code{factor} object with the colours intended for \code{conv.hulls}. Must be the same length as the number of levels in \code{conv.hulls} (i.e. \code{length(col.conv) == length(levels(conv.hulls))}). By default: \code{col.conv = grDevices::rainbow(length(levels(conv.hulls)))} (i.e. colors defined automatically)}

\item{leg}{a logical. If \code{TRUE}, a legend is added to plot. By default: \code{leg = FALSE}}

\item{leg.labels}{only applies when \code{leg = TRUE}. Must be the same length of levels in \code{groups} (i.e. \code{length(leg.labels) == length(levels(groups))}). By default: \code{leg.labels = groups} (i.e. labels will be the same as the levels from \code{groups})}

\item{leg.pos}{specify legend location in the plot by using a keyword from the list: \code{"bottomright"}, \code{"bottom"}, \code{"bottomleft"}, \code{"left"}, \code{"topleft"}, \code{"top"}, \code{"topright"}, \code{"right"} and \code{"center"}. Alternatively, a single value can be provided and used for both margins, or two values, in which the first is used for X distance, and the second for Y distance. See also \code{\link{legend}} for details. By default: \code{leg.pos = "topright"}}

\item{main}{main title of output plot. Should be presented between quotation marks. By default: \code{main = "Ordination of PCA coordinates"}}

\item{sp.as}{enables one to choose between ploting elements as \code{"points"} or \code{"text"}. If \code{sp.as = "text"}, then one must also input a \code{factor} of characters to use as text (i.e. \code{sp.text}). By default: \code{sp.as = "points"}}

\item{sp.text}{only applies when \code{sp.as = "text"}. A \code{factor} including elements as texts intended in the plot. Has to be the same length as the number of rows in the coordinates of \code{PCA.out} (i.e. \code{length(sp.text) == nrow(PCA.out$x)}) . By default: \code{sp.text = NULL}}
}
\value{
Require the output of \code{prcomp} and a vector with \code{groups} to plot. In addition, it is also possible to include convex hulls around each group (i.e. \code{conv.hulls}) and to control the colors intended for each group (i.e. \code{col.gp}) and for each convex hull (i.e. \code{col.conv}).
}
\description{
Ordination of Principal Components from the output of a PCA performed by \code{\link{prcomp}} function (\code{\link{stats}} package).
}
\examples{
library(seewave)
library(tuneR)

# Create folder at current working directory to store wave files
wav.at <- file.path(getwd(), "example SoundShape")
dir.create(wav.at)

# Create folder to store results
store.at <- file.path(getwd(), "example SoundShape/output")
dir.create(store.at)

# Select three acoustic units within each sound data
data("tico")
spectro(tico) # Visualize sound data that will be used

# Cut acoustic units from original wave
cut.tico1 <- cutw(tico, f=44100, from=0, to=0.22, output = "Wave")
cut.tico2 <- cutw(tico, f=44100, from=0.22, to=0.44, output = "Wave")
cut.tico3 <- cutw(tico, f=44100, from=0.44, to=0.66, output = "Wave")

data("orni")
spectro(orni) # Visualize sound data that will be used

# Cut acoustic units from original wave
cut.orni1 <- cutw(orni, f=44100, from=0, to=0.08, output = "Wave")
cut.orni2 <- cutw(orni, f=44100, from=0.12, to=0.22, output = "Wave")
cut.orni3 <- cutw(orni, f=44100, from=0.21, to=0.29, output = "Wave")

# Export wave files containing acoustic units and store on previosly created folder
writeWave(cut.tico1, filename = file.path(wav.at, "cut.tico1.wav"), extensible = FALSE)
writeWave(cut.tico2, filename = file.path(wav.at, "cut.tico2.wav"), extensible = FALSE)
writeWave(cut.tico3, filename = file.path(wav.at, "cut.tico3.wav"), extensible = FALSE)
writeWave(cut.orni1, filename = file.path(wav.at, "cut.orni1.wav"), extensible = FALSE)
writeWave(cut.orni2, filename = file.path(wav.at, "cut.orni2.wav"), extensible = FALSE)
writeWave(cut.orni3, filename = file.path(wav.at, "cut.orni3.wav"), extensible = FALSE)

# Place sounds at beggining of sound window before analysis
align.wave(wav.at = wav.at, wav.to = "Aligned",
           time.length = 0.3, time.perc = 0.01, dBlevel = 25)

# Verify alignment using analysis.type = "twoDshape"
eigensound(analysis.type = "twoDshape", wav.at = file.path(wav.at, "Aligned"),
           store.at = store.at, flim=c(3, 18), tlim=c(0,0.22),
           plot.exp = TRUE, plot.as = "jpeg", dBlevel = 25)
# Go to folder specified by store.at and check jpeg files created

# Run eigensound function using analysis.type = "threeDshape" on aligned wave files
# Store results as R object and tps file
eig.sample <- eigensound(analysis.type="threeDshape", flim=c(3, 18), tlim=c(0,0.22), dBlevel = 25,
                   wav.at = file.path(wav.at, "Aligned"), store.at = store.at,
                   x.length = 80, y.length = 60, TPS.file = "eigensound.sample.tps", log.scale = TRUE,
                   plot.exp = TRUE, plot.as = "jpeg", plot.type = "surface")
# Go to folder specified by store.at and check jpeg files created

# PCA using three-dimensional semilandmark coordinates
pca.eig.sample <- stats::prcomp(geomorph::two.d.array(eig.sample))

# Create factor to use as groups in subsequent plot of principal components
sample.gr <- factor(c(rep("orni", 3), rep("tico", 3)))

# Clear current R plot to prevent errors
dev.off()

# Plot result of Principal Components Analysis
pca.plot(PCA.out = pca.eig.sample, groups = sample.gr, conv.hulls = sample.gr,
         main="PCA of 3D coordinates", leg=TRUE, leg.pos = "bottomleft")

}
\references{
Rocha, P. & Romano, P. (\emph{in prep}) The shape of sound: A new \code{R} package that crosses the bridge between Geometric Morphometrics and Bioacoustics.
}
\seealso{
\code{\link{prcomp}}, \code{\link{palette}}, \code{\link{rgb}}, \code{\link{rainbow}}, \code{\link{legend}}

Useful links:
\itemize{
  \item{\url{https://github.com/p-rocha/SoundShape}}
  \item{Report bugs at \url{https://github.com/p-rocha/SoundShape/issues}}}
}
\author{
Pedro Rocha
}
